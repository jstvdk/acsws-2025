import sqlite3
from pathlib import Path
import threading
import TYPES

import DATABASE_MODULE__POA      # IDL stubs
from Acspy.Servants.ACSComponent import ACSComponent
from Acspy.Servants.ContainerServices import ContainerServices
from Acspy.Servants.ComponentLifecycle import ComponentLifecycle


DB_DIR   = Path(__file__).resolve().parent / "data"
DB_DIR.mkdir(exist_ok=True)

STATUS_INITIAL_PROPOSAL = 0
STATUS_NO_SUCH_PROPOSAL = -999

SCHEMA_SQL = """
PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS proposal (
    id         INTEGER PRIMARY KEY AUTOINCREMENT,
    status     INTEGER NOT NULL,
    created_at DATETIME NOT NULL DEFAULT (datetime('now')),
    updated_at DATETIME NOT NULL DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS target (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    proposal_id INTEGER NOT NULL REFERENCES proposal(id) ON DELETE CASCADE,
    ra          REAL NOT NULL,
    dec         REAL NOT NULL,
    name        TEXT,
    UNIQUE (proposal_id, ra, dec)
);

CREATE TABLE IF NOT EXISTS image (
    id          INTEGER PRIMARY KEY AUTOINCREMENT,
    proposal_id INTEGER NOT NULL REFERENCES proposal(id) ON DELETE CASCADE,
    target_id   INTEGER          REFERENCES target(id) ON DELETE CASCADE,
    file_uri    TEXT NOT NULL,
    captured_at DATETIME NOT NULL,
    meta_json   TEXT,
    UNIQUE (proposal_id, file_uri)
);
"""

class ProposalHandler(DATABASE_MODULE__POA.DataBase,
                      ACSComponent,
                      ContainerServices,
                      ComponentLifecycle):

    def __init__(self):
        ACSComponent.__init__(self)
        ContainerServices.__init__(self)

        self._logger = self.getLogger()

        self.db_file  = DB_DIR / "proposals.sqlite"
        
        self._db = sqlite3.connect(self.db_file, detect_types=sqlite3.PARSE_DECLTYPES)


    def execute(self):
        with self._lock:
            self._db   = sqlite3.connect(self.db_file,
                                        check_same_thread=False)  # <── key change
            self._lock = threading.Lock()
            self._db.execute("PRAGMA journal_mode = WAL;")      # better concurrency
            self._db.execute("PRAGMA synchronous  = NORMAL;")   # good durability/latency trade-off
            self._db.execute("PRAGMA foreign_keys=ON;")
            
            self._db.executescript(SCHEMA_SQL)
            self._logger.info(f"SQLite initialised at {self.db_file}")

    def storeProposal(self, targets):
        """
        Inserts a proposal row with STATUS_INITIAL_PROPOSAL
        and N targets; returns the autogenerated proposal ID.
        """
        cur = self._db.cursor()
        cur.execute("BEGIN;")
        cur.execute("INSERT INTO proposal(status) VALUES (?);",
                    (STATUS_INITIAL_PROPOSAL,))
        pid = cur.lastrowid

        cur.executemany(
            "INSERT INTO target(proposal_id, ra, dec, name) VALUES (?, ?, ?, ?);",
            [(pid, t.ra, t.dec, getattr(t, "name", None)) for t in targets]
        )
        self._db.commit()
        return pid

    def getProposalStatus(self, pid: int) -> int:
        """Gets the status of a proposal. Returns a dummy status."""
        return 0

    def removeProposal(self, pid: int) -> None:
        """Removes a proposal. Dummy implementation does nothing."""
        pass

    def getProposalObservations(self, pid: int) -> TYPES.ImageList:
        """Returns a list of dummy images for a proposal."""
        return TYPES.ImageList()

    def getProposals(self) -> list:
        """Returns a list of dummy pending proposals."""
        return TYPES.ProposalList()

    def setProposalStatus(self, pid: int, status: int) -> None:
        """Sets a proposal status. Dummy implementation does nothing."""
        pass

    def storeImage(self, pid: int, tid: int, image: TYPES.ImageType) -> None:
        """Stores an image for a proposal and target. Dummy implementation does nothing."""
        return None
    
    def clean(self) -> None:
        """Cleans up the database. Dummy implementation does nothing."""
        pass

    def cleanUp(self): 
        with self._lock:
            try:
                self._db.close()
            finally:
                super().cleanUp()
